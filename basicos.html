<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fundamentos de JavaScript</title>
</head>

<body>
    <h1>Fundamentos JavaScript</h1>
    <script>
        console.log("***** VAR y LET*****")
        var hola = "hola var"
        let hello = "hello let"
        console.log(hola)
        console.log(hello)
        console.log(window.hola)
        console.log(window.hello)


        // VAR vs LET
        console.log("*****EJEMPLOS VAR y LET*****")
        //ambito de bloque
        console.log("*****ejemplo con VAR*****")
        var musica = 'ROCK'
        console.log('variable musica antes del bloque', musica)
        //Esto es un bloque: ejemplo de hoisting
        {
            var musica = "CLASICA de Mozart"
            console.log('variable musica dentro del bloque', musica)
        }
        console.log('variable musica despues del bloque', musica)
        //Conclusión: los scopes de var son por funcion o global, por ello eleva(hoisting) el var dentro del bloque (var musica = "Clasica de Mozart") , lo saca de éste y sobreescribe a la primera.

        console.log("*****ejemplo con LET*****")
        let musica2 = 'ROCK'
        console.log('variable musica antes del bloque', musica2)

        {
            let musica2 = "CLASICA de Mozart"
            console.log('variable musica dentro del bloque', musica2)
        }
        console.log('variable musica despues del bloque', musica2)
        console.log("----------------------------------------------------------------")
        console.log("***** ejemplo NUMEROS*****")
        console.log("*****concatenacion numero + string*****")
        //los datos enviados mediate formulario siempre son de tipo string, por lo tanto los numeros se transforman en tipo string.Por ello se deberá hacer un casting(o parsear);Esto quiere decir que se cambia el tipo de dato para, en este caso, realizar operaciones con números(operacion aritmética).
        let numero = 1234;
        let string = "iñigo"
        let stringNumero = "1234"
        let numero2 = 123
        let numero3 = 1.2345
        let concatenacion1 = numero + string;
        let concatenacion2 = numero + stringNumero;
        let concatenacion3 = numero + numero2;

        console.log(concatenacion1)
        console.log(concatenacion2)
        console.log(concatenacion3)

        console.log(typeof numero, "------------>", numero)
        console.log(typeof string, "------------>", string)
        console.log(typeof concatenacion1, "------------>", concatenacion1)
        console.log(typeof concatenacion2, "------------>", concatenacion2)
        console.log(typeof concatenacion3, "------------>", concatenacion3)
        console.log("------------metodos del objeto Number----------")

        console.log("método toFixed()", "------------>", numero3.toFixed(1))//modifica la cantidad de decimales
        console.log("método parseInt()", "------------>", parseInt(numero3))//devuelve parte entera
        console.log(`método Number() sobre variable stringNumero de valor: ${stringNumero} y tipo de dato: ${typeof stringNumero}   ------------------>    valor:${Number(stringNumero)} y tipo de dato: ${typeof Number(stringNumero)}`)


        console.log("----------------------------------------------------------------")
        console.log("***** ejemplo BOOLEANS*****")


        console.log(`valores falsy: 7    `)
        console.log(`1-----> 0 -----> ${Boolean(0)}`)
        console.log(`6-----> false----> ${Boolean(false)}`)
        console.log(`5-----> "" o '' (string vacío)------> ${Boolean("")}`)
        console.log(`4-----> undefined ---->${Boolean(undefined)}`)
        console.log(`2-----> null --->${Boolean(null)}`)
        console.log(`3-----> NaN ----->${Boolean(NaN)}`)
        console.log(`7-----> nodo no existente. Window.document.all---> ${Boolean(document.all)}`)


        console.log("***** ejemplo FUNCIONES*****")

        function funcionDevuelveValor() {
            console.log("uno")
            console.log("dos")
            console.log("tres")
            console.log("cuatro")
            console.log("cinco")
            return "terminó la función antes del seis"
        }

        const valorFuncion = funcionDevuelveValor()
        console.log(valorFuncion)//devuelve el valor de la funcion(return) por consola.

        console.log("---funcion con parametros---")
        function saludo(nombre = "desconocido", edad = 0) {
            console.log(`hola me llamo ${nombre} y tengo ${edad} años de edad`)
        }
        saludo()
        saludo("iñigo", 33)
        saludo("iñigo", "33")

        console.log("*****funciones declaradas vs funciones expresadas*****")
        console.log("---funciones declaradas---")
        duncionDeclarada()//javascript hace hoisting(elevacion de la funcion); JS ordena primero variables y luefo funciones.Por eso podemos invocar antes de declarar. 

        function duncionDeclarada() {
            console.log("Esto es una funcion declarada, puede invocarse en cualquier parte de nuestro código, incluso antes de que la función sea declarada")
        }

        duncionDeclarada()

        console.log("---funciones expresadas---")
        //utilizar las funciones como expresiones, es decir, crear una funcion y sasignarsela dinámicamente a una variable.

        //funcion anónima:

        // funcionExpresada()//da error ReferenceError.--

        const funcionExpresada = function () {
            console.log("esto es una funcion expresada, es decir que, una funcion que se le ha asignado como valor a una variable, si invocamos esta funcion antes de su declaracion JS nos dirá...")
        }
        funcionExpresada();//se muestra por consola.

        console.log("***** ejemplo ARRAYS*****")


        const colores = ["Rojo", "Verde", "Azul"];
        console.log(colores)
        colores.push("Naranja")
        console.log(colores)
        colores.forEach(function (element, index) {
            console.log(`<li id="${index}">${element}</li>`)
        })


        console.log("***** ejemplo OBJECTS*****")


        const Inigo = {
            nombre: "Inigo",
            apellido: "Malluguiza",
            edad: 33,
            pasatiempos: ["Esquí", "Rugby", "repostería"],
            soltero: false,
            contacto: {
                email: "inigomail@gmail.com",
                twitter: "@IngoTwitter",
                movil: "123456789"
            },
            saludar: function () {
                console.log("hola")
            },
            decirMiNombre: function () {
                console.log(`Hola me llamo ${this.nombre} ${this.apellido} y tengo ${this.edad} años. Me puedes segui como ${this.contacto.twitter} en twitter`)
            }

        }
        console.log(Inigo);
        console.log(Inigo.apellido);
        console.log(Inigo.pasatiempos[0]);
        console.log(Inigo.contacto.movil);
        Inigo.saludar()
        Inigo.decirMiNombre()


        console.log("***** ejemplo CONDICIONALES*****")
        console.log("---Métodos de Object---")

        console.log(Object.keys(Inigo))
        console.log(Object.values(Inigo))
        console.log(`con el método hasOwnProperty() podemos saber si la key "nombre" está contenida en el objeto Inigo: ${Inigo.hasOwnProperty("apellido")}`)
        console.log(Object.entries(Inigo) + "------------------------------")



        console.log("***** ejemplo OPERADORES aritméticos*****")
        // se corresponden a suma,resta,multiplicación,division y módulo
        let division = 5 / 2
        let modulo = 5 % 2
        console.log(`la variable division devuelve el cociente(resultado de la division) ${division}`)
        console.log(`la variable division devuelve el residuo o resto ${modulo}`)

        console.log("***** ejemplo OPERADORES relacionales*****")

        //= es asignacion
        //== es comparacion de valor
        console.log(`la operacion 7==7 es ${7 == 7}`)
        console.log(`la operacion "7"==7 es ${"7" == 7}`)
        //=== es comparacion de valor y tipo de dato
        console.log(`la operacion 7===7 es ${7 === 7}`)
        console.log(`la operacion "7"===7 es ${"7" === 7}`)


        console.log("***** ejemplo LOOPS*****")

        // console.log("while:")
        //estructura imperativa de programacion estructurada.

        let contador = 0;
        // contador < 10 ===> bucle infinito, hace falta incremento(++).
        while (contador < 10) {
            contador++
            console.log("while", contador)
        }


        // console.log(" do while:")

        do {
            console.log(" do while", contador)
            contador++
        } while (contador < 10)


        console.log("for:")

        let ArrayNum = ["cero", "uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez"]

        for (let i = 0; i < ArrayNum.length; i++) {
            console.log(i, ArrayNum[i])
        }


        const PruevaObject = {
            nombre: "ini",
            apellido: "Malluki",
            edad: 45
        }
        //for in para iterar las propiedades de un objeto primitivo
        //si queremos imprimir el valor de la propiedad de un objeto , la notacion del punto nos dará undefined.
        for (const propiedad in PruevaObject) {
            console.log(`key:${propiedad}, value: ${PruevaObject[propiedad]}`)
        }
        //for of permite recorrer o iterar los elementos de cualquier objeto en JS que sea iterable(que se puedan partir en pequeños elementos: strings, arrays, numeros...).
        for (const elemento of ArrayNum) {
            console.log(elemento)
        }
        let cadena = "Hola Mundo"
        for (const elemento of cadena) {
            console.log(elemento)
        }

        console.log("*****Ejemplo estructura de manejo de ERRORES:estructura => try-catch-finaly***** ")

        try {
            console.log("En el try se agrega el códio a evaluar.")
            error
            console.log("Segundo mensaje en el try.")

        } catch (error) {
            console.log("Catch captura cualquier error surgido o lanzado en el try.")
        } finally {
            console.log("El bloque finaly, se ejecutará siempre al final de un bloque try-catch.")
        }



        try {
            let number = "23";

            if (isNaN(number)) {
                throw new Error("El carácter introducido no es un Número")
            }
            console.log(number * number)

        } catch (error) {
            console.log(`Se produjo el siguiete error:${error}`)
        }

        console.log("*****Ejemplo break & continue***** ")
        //estas dos palabras no se pueden utilizar con metodos de los arrays como forEach.Están pensadas para ser utilizadas en estructuras de control como for,while,do while,if, switch, case, etc.
        const array = ["cero", 1, "dos", 3, "cuatro", 5, "seis", 7, "ocho", 9, "diez"]

        for (let i = 0; i < array.length; i++) {
            if (i === 5) {
                break;
            }
            console.log(array[i])
        }
        console.log("-----------------------")

        for (let i = 0; i < array.length; i++) {
            if (i === 5) {
                continue;
            }//salta la itesación numero 5
            console.log(array[i])
        }


        console.log("*****Destructuring***** ")

        let arreglo = [1, 2, 3]

        //Sin destructuración
        let uno = arreglo[0],
            dos = arreglo[1],
            tres = arreglo[2];

        console.log(uno, dos, tres)

        //Con destructuración
        const [one, two, three] = arreglo

        console.log(one, two, three);


        let usuario = {
            nombre: "Jon",
            apellido: "Martinez",
            edad: 50
        }
        //destructuramos el objeto usuario de la siguiente manera:
        let { nombre, apellido, age } = usuario
        console.log(nombre, apellido, age)
        //IMP: al destructurar las propiedades de un objeto se debe respetar los nombres de las propiedades del mismo.

        console.log("*****Objetos Literales***** ");
        //nueva forma de escribir atributos y metodos (incluso de saignarlos).
        //Sin nuevas caracteristicas de objetos literales:
        let nombre1 = "Argos",
            edad = 10;
        const perro = {
            nombre1: nombre1,
            edad: edad,
            ladrar: function () {
                console.log("guauuuuu guauuu")
            }
        }

        console.log(perro)
        perro.ladrar()

        //-----nuevas características-----------:simplificar.A partir del estandar ES6(2015)
        const dog = {
            nombre1,
            edad,
            raza: "mastín",
            ladrar() {
                console.log("soy un perro guaui guau...")
            }
        }
        console.log(dog)
        dog.ladrar()

        console.log("***** Parámetros REST & Operador Spread***** ");
        //parámetro REST:
        //parámetros que recibe una función
        function sumar(a, b, ...c) {
            let result = a + b

            c.forEach(function (n) {
                result += n
            })
            return result
        }
        console.log(sumar(1, 2))
        console.log(sumar(1, 2, 3, 4, 34, 2, 3, 45, 123))

        //Spread Operator u operador de propagación:
        //se puede ejecutar en cualquier sentencia de nuestro código.Quita las llaves y accede a los valores.

        const arr1 = [1, 2, 3, 4, 5, 6, 7],
            arr2 = [8, 9, 10, 11, 12, 13, 14, 15];

        console.log(arr1, arr2);

        const arr3 = [...arr1, ...arr2]

        console.log(arr3);


        console.log("*****Arrow Functions***** ")
        //nueva manera de simplificar las funciones expresadas(funciones anónimas).

        const arrow = function () {
            console.log("Hola, soy un arco expresado tradicional")
        }

        const arrowSimple = nombre => console.log(`Hola, soy un arco expresado simplificado y me llamo: ${nombre}`)

        arrow()
        arrowSimple("Irma")

        // const sumar2 = function (a, b) {
        //     return a + b
        // }
        // console.log(sumar2(1, 1))
        //se puede simplificar como:nos ahorramos el return(está implícito)
        const sumar2 = (a, b) => a + b
        console.log(sumar2(10, 10))

        const letras = ["a", "b", "c", "d", "e", "f", "g", "h"];

        letras.forEach(function (elem, index) {
            console.log(`el elemento: ${elem}, está en la posición :${index}`)
        })
        console.log("-----------con arrow function------")

        letras.forEach((elem, index) => console.log(`${elem}, está en la posición :${index}`))

        //IMPORTANTE: LAS ARROW FUNCTIONS TIENEN LA CAPACIDAD DE CAPTURAR EL OBJETO "THIS" DEL CONTEXTO EN EL QUE SE ENCUENTREN.EJEMPLO:

        // function samurai() {
        //     console.log(this)
        // }
        //como la funcion existe dentro del contexto del navegador, this se refiere al objeto window.
        // samurai()

        const huno = {
            nombre: "Atila",
            tribu: "hunos",
            gritar: function () {
                console.log(`soy ${this.nombre} y con la function expresada tradicional me refiero al objeto:`, this)
            },
            status() {
                console.log(`El rey de los ${this.tribu} soy YO:${this.nombre}aaaa!!!`)
            },//forma de declarar métodos en objetos literales, igual al método anterior, pero más simplificado.
        }

        huno.gritar()//this en este contexto se refiere al objeto huno.
        huno.status()


        const huno2 = {
            nombre: "Atila",
            gritar: () => {
                console.log(`soy ${huno2.nombre} y con la function expresada arrow me refiero al objeto:`, this)
            },
        }

        huno2.gritar()//this en este contexto se refiere al objeto window.

        //HAY QUE TENER MUCHO CUIDADO CON UTILIZAR ARROW FUNCTIONS PARA DECLARAR MÉTODOS DENTRO DE OBJETOS LITERALES.UNA FUNCION NORMAL RESPETA EL CONTEXTO EN EL QUE SE ENCUENTRA.Utilizar function expresada tradicional(no arrow) para metodos de objetos literales.

        console.log("*****Prototipos******")

        // const hoplita = {
        //     nombre: "Jasón",
        //     gritoDeGuerra() {
        //         console.log(`soy ${this.nombre} y lucho POR ESPARTAAAAAAA`)
        //     }
        // };

        // const hoplita2 = {
        //     nombre: "Carlos",
        //     gritoDeGuerra() {
        //         console.log(`soy ${this.nombre} y lucho POR ESPARTAAAAAAA`)
        //     }
        // };

        // hoplita.gritoDeGuerra()
        // hoplita2.gritoDeGuerra()
        // console.log(hoplita)
        // console.log(hoplita2)

        //para realizar un modelo que nos permita generar N hoplitas de manera rápida y eficiente.

        // //funcion constructora:
        // function Infante(nombre, rango) {
        //     //Atributos
        //     this.nombre = nombre;
        //     this.rango = rango;
        //     //métodos
        //     this.gritoDeGuerra = function () {
        //         console.log('lucho POR ESPARTAAAAAAA')
        //     }
        //     //metodos para objetos literales no aplican para funciones constructoras(this.grito()->NO).
        //     this.saludar = function () {
        //         console.log(`Hola me llamo ${this.nombre}`)
        //     }
        // }

        // const jason = new Infante("Jason", "soldado"),
        //     carlos = new Infante("Carlos", "veterano")

        // console.log(jason, carlos)

        // jason.gritoDeGuerra()
        // jason.saludar()

        // carlos.gritoDeGuerra()
        // carlos.saludar()
        //IMP: LAS FUNCIONES CONSTRUCTORAS SÓLO DEBEN CONTENER LOS ATRIBUTOS, PARA EVITAR DUPLICIDADES CON LOS MÉTODOS, COMO EL EJEMPLO ANTERIOR.

        //procedemos a sacar los métodos de la funcion constructora:
        //-----------funcion constructora:--------
        function Infante(nombre, rango) {
            //Atributos
            this.nombre = nombre;
            this.rango = rango;
        }

        //Métodos agregados al prototipo de la funcion constructora:
        Infante.prototype.gritoDeGuerra = function () {
            console.log('lucho POR ESPARTAAAAAAA')
        }
        //metodos para objetos literales no aplican para funciones constructoras(this.grito()->NO).
        Infante.prototype.saludar = function () {
            console.log(`Hola me llamo ${this.nombre}`)
        }

        // const jason = new Infante("Jason", "soldado"),
        //     carlos = new Infante("Carlos", "veterano")

        // console.log(jason, carlos)

        // jason.gritoDeGuerra()
        // jason.saludar()

        // carlos.gritoDeGuerra()
        // carlos.saludar()

        console.log("*****Herencia Prototípica******")

        //herencia prototípica:

        function Hoplita(nombre, rango, tamanio) {
            this.super = Infante;//invocamos constructor Infante.
            this.super(nombre, rango);
            this.tamanio = tamanio;
        }

        //asignar al prototipo de Hoplita, que sea una instancia(copia del modelo) de Infante.Por tanto:
        //Hoplita está heredando de Infante.
        Hoplita.prototype = new Infante();
        Hoplita.prototype.constructor = Hoplita;

        //Sobreescritura de método del Prototipo padre en el hijo.Redefinimos:

        Hoplita.prototype.gritoDeGuerra = function () {
            console.log("Desperta ferro!!")
        }

        Hoplita.prototype.opinion = function () {
            console.log("La guerra es un juego macabro")
        }

        const jason = new Hoplita("Jason", "soldado", "mediano"),
            carlos = new Infante("Carlos", "veterano")

        console.log(jason)
        console.log(carlos)

        jason.gritoDeGuerra()
        jason.saludar()
        jason.opinion()


        carlos.gritoDeGuerra()
        carlos.saludar()


        console.log("*****Clases y Herencia******")

        //las clases no reciben parámetros:
        class Animal {
            //método especial, se ejecuta en el mometo de instaciar la clase:
            constructor(nombre, genero) {
                this.nombre = nombre
                this.genero = genero
            }
            sonar() {
                console.log("Soy un ser vivo y emito sonidos")
            }

            saludar() {
                console.log(`Hola me llamo ${this.nombre}`)
            }
        }

        // const mimi = new Animal("Mimi", "Hembra"),
        //     scooby = new Animal("Scooby", "Macho")


        // console.log(mimi);
        // mimi.sonar()
        // mimi.saludar()

        // console.log(scooby);
        // scooby.sonar()
        // scooby.saludar()

        //utilizamos el método super, que llama al constructor de una clase.

        // class Perro extends Animal {
        //     constructor(nombre, genero, tamanio) {
        //         //metodo super() llama al constructor de la clase padre; Es este caso Animal.
        //         super(nombre, genero)
        //         //propiedad tamanio, exclusiva de la clase perro.
        //         this.tamanio = tamanio;
        //     }
        //     sonar() {
        //         console.log("Piiiiiiiiiiiiiiiiiiiiii")
        //     }
        //     ladrar() {
        //         console.log("guaaaaaaaaaaaaaaaaaaaaaaaaaaauuuuuu")
        //     }
        // }


        // const mimi = new Animal("Mimi", "Hembra"),
        //     scooby = new Perro("Scooby", "Macho", "Gigante")
        // console.log(mimi);
        // mimi.sonar()
        // mimi.saludar()

        // console.log(scooby);
        // scooby.sonar()
        // scooby.saludar()
        // scooby.ladrar()

        console.log("*****Métodos estáticos, getters y setters*****")
        //en JS todas la clases son públicas.

        class Perro extends Animal {
            constructor(nombre, genero, tamanio) {
                super(nombre, genero)
                this.tamanio = tamanio;
                this.raza = null //getter y setter modifican este valor.
            }
            sonar() {
                console.log("Piiiiiiiiiiiiiiiiiiiiii")
            }
            ladrar() {
                console.log("guaaaaaaaaaaaaaaaaaaaaaaaaaaauuuuuu")
            }
            static queEres() {
                console.log("Los perros somos los mejores amigos del hombre.")
            }
            //---setters y getters---, métodos especiales que permiten establecer y obtener valores de los atributos de nuestra clase.
            get getRaza() {
                return this.raza
            }
            set setRaza(raza) {
                this.raza = raza
            }
            //son metodos, pero se utilizan como atributos.
        }

        //metodo estático se puede ejecutar sin necesidad de instaciar la clase.
        Perro.queEres()

        const mimi = new Animal("Mimi", "Hembra"),
            scooby = new Perro("Scooby", "Macho", "Gigante")

        console.log(mimi);
        mimi.sonar()
        mimi.saludar()
        console.log(scooby);
        scooby.sonar()
        scooby.saludar()
        scooby.ladrar()
        console.log(scooby.getRaza)
        scooby.setRaza = "BullDog"
        console.log(scooby.getRaza)


        const person = {
            firstName: "Eneco",
            lastName: "patxi",
            get fullName() {
                return `${this.firstName} ${this.lastName}`
            },
            set fullName(value) {
                const parts = value.split(' ')
                this.firstName = parts[0]
                this.lastName = parts[1]
            }
        }

        console.log(person.fullName)
        person.fullName = 'María Fernandez'
        console.log(person);


        console.log("*****Objeto console*****")


        console.log(console)
        console.error("Esto es un error")
        console.warn("Esto es un aviso")
        console.info("Esto es un mensaje informativo")
        console.log("Esto es un registro de lo quie ha pasado en nuestra aplicación")

        let jugador = "Jon",
            apellido1 = 'Novo',
            edad1 = 30;

        console.log(jugador)
        console.log(apellido1)
        console.log(edad1)
        console.log(jugador, apellido1, edad1)
        console.log(`Hola mi nombre es ${jugador} ${apellido1} y tengo ${edad1} años`)

        console.clear()
        console.log("empezamos nueva leccion")

        console.log(window)
        console.log(document)
        console.dir(window)
        console.dir(document)

        console.clear()

        console.group("Los cursos de javaScript")
        console.log("curso 1")
        console.log("curso 2")
        console.log("curso 3")
        console.log("curso 4")
        console.log("curso 5")
        console.log("curso 6")
        console.log("curso 7")
        console.groupEnd()

        console.groupCollapsed("Los cursos de javaScript")
        console.log("curso 1")
        console.log("curso 2")
        console.log("curso 3")
        console.log("curso 4")
        console.log("curso 5")
        console.log("curso 6")
        console.log("curso 7")
        console.groupEnd()

        console.log(console)
        console.table(Object.entries(console).sort())

        console.clear()

        const numeros = [1, 2, 3, 4, 5],
            vocales = ["a", "e", "i", "o", "u"]

        console.table(numeros)
        console.table(vocales)

        console.clear()

        const pajaro = {
            nombre: "Pepito",
            raza: "periquito",
            color: "rojo"
        }
        console.table(pajaro)

        console.clear()

        console.time("Etiqueta")

        // const arreglo = new Array(1000) --->forma antigua, en deshuso.

        const arreglo2 = Array(1000000)



        for (let i = 0; i < arreglo2.length; i++) {
            arreglo2[i] = i
        }

        console.timeEnd("Etiqueta")
        // console.log(arreglo2)// para no consumir deamriados recursos lo comentamos.

        console.clear()

        for (let i = 0; i <= 100; i++) {
            console.count("código for")
            console.log(i)
        }

        console.clear()
        //para comenza a hacer pequeñas pruevas unitarias:con assert.
        let x = 3,
            y = 2, pruebaXY = "Se espera que X siempre sea menor que Y"

        console.assert(x < y, { x, y, pruebaXY })

        console.clear()

        console.log("*****Objeto Date*****")

        console.log(Date())

        let fecha = new Date()
        console.log(fecha)

        //día del mes
        console.log(`día del mes: ${fecha.getDate()}`)
        //día de la semana D L M MI J V S -> 0 1 2 3 4 5 6
        console.log(`día de la semana D L M MI J V S -> 0 1 2 3 4 5 6/----->resultado: ${fecha.getDay()}`)
        //mes Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic --> 0 1 2 3 4 5 6 7 8 9 10 11 
        console.log(`mes Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic --> 0 1 2 3 4 5 6 7 8 9 10 11/----> resultado:  ${fecha.getMonth()}`)

        console.log(fecha.getFullYear())
        console.log(fecha.getHours())
        console.log(fecha.getMinutes())
        console.log(fecha.getSeconds())
        console.log(fecha.getMilliseconds())
        console.log(fecha.toString())
        console.log(fecha.toDateString())
        console.log(fecha.toLocaleString())
        console.log(fecha.toLocaleDateString())
        console.log(fecha.toLocaleTimeString())
        console.log(`minutos que faltan para llegar a la hora cero de londres:${fecha.getTimezoneOffset()}`)
        console.log(fecha.getUTCDate())
        console.log(fecha.getUTCHours())
        console.log(`representa el instante expresado en cuantos segundos que han pasado desde el 1 de enero de 1970:${Date.now()} fecha timestamp`)
        //ejemplo:
        let cumpleIni = new Date(1989, 2, 11)
        console.log(cumpleIni)

        //LIBRERIA Moment.JS para manejar tiempo en tu api.



        console.log("*****Objeto Math*****")
        //se trata de un objeto statico.
        console.log(Math)
        console.log(Math.abs(-10.2))
        console.log(Math.ceil(10.2))
        console.log(Math.floor(10.9))
        console.log(Math.round(10.49))
        console.log(Math.sqrt(81))
        console.log(Math.pow(9, 2))
        console.log(Math.sign(-100))//-1 0 1(devuelve signo)
        console.log(Math.random())
        console.log(Math.round(Math.random() * 100))
        //devuelve un numero entero aleatorio comprendido entre el 0 y el 100.

        console.clear()
        console.log("*****Operador de Cortocircuito*****")
        //operadores lógicos AND & OR

        //Cortocircuito OR -cuando el valor de la izquierda en la expresión siempre pueda validad a TRUE, es el valor que se cargará por defecto.

        //Cortocircuito AND -cuando el valor de la izquierda en la expresión siempre pueda validad a FALSE, es el valor que se cargará por defecto.

        function salute(nombre) {
            nombre = nombre || "Desconocido"
            console.log(`Hola ${nombre}`)
        }
        salute("Javier")
        salute()
        //truthy
        let cortocircuito = "cadena" || "Valor de la derecha"
        let cortocircuito2 = 19 || "Valor de la derecha"
        let cortocircuito3 = true || "Valor de la derecha"
        let cortocircuito4 = [] || "Valor de la derecha"
        let cortocircuito5 = {} || "Valor de la derecha"
        //falsy:
        let cortocircuito6 = 0 || "Valor de la derecha"
        let cortocircuito7 = '' || "Valor de la derecha"
        let cortocircuito8 = null || "Valor de la derecha"


        console.log(cortocircuito)
        console.log(cortocircuito2)
        console.log(cortocircuito3)
        console.log(cortocircuito4)
        console.log(cortocircuito5)
        console.log(cortocircuito6)
        console.log(cortocircuito7)
        console.log(cortocircuito8)

    </script>
</body>

</html>