<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fundamentos de JavaScript</title>
</head>

<body>
    <h1>Fundamentos JavaScript</h1>
    <script>
        console.log("***** VAR y LET*****")
        var hola = "hola var"
        let hello = "hello let"
        console.log(hola)
        console.log(hello)
        console.log(window.hola)
        console.log(window.hello)


        // VAR vs LET
        console.log("*****EJEMPLOS VAR y LET*****")
        //ambito de bloque
        console.log("*****ejemplo con VAR*****")
        var musica = 'ROCK'
        console.log('variable musica antes del bloque', musica)
        //Esto es un bloque: ejemplo de hoisting
        {
            var musica = "CLASICA de Mozart"
            console.log('variable musica dentro del bloque', musica)
        }
        console.log('variable musica despues del bloque', musica)
        //Conclusión: los scopes de var son por funcion o global, por ello eleva(hoisting) el var dentro del bloque (var musica = "Clasica de Mozart") , lo saca de éste y sobreescribe a la primera.

        console.log("*****ejemplo con LET*****")
        let musica2 = 'ROCK'
        console.log('variable musica antes del bloque', musica2)

        {
            let musica2 = "CLASICA de Mozart"
            console.log('variable musica dentro del bloque', musica2)
        }
        console.log('variable musica despues del bloque', musica2)
        console.log("----------------------------------------------------------------")
        console.log("***** ejemplo NUMEROS*****")
        console.log("*****concatenacion numero + string*****")
        //los datos enviados mediate formulario siempre son de tipo string, por lo tanto los numeros se transforman en tipo string.Por ello se deberá hacer un casting(o parsear);Esto quiere decir que se cambia el tipo de dato para, en este caso, realizar operaciones con números(operacion aritmética).
        let numero = 1234;
        let string = "iñigo"
        let stringNumero = "1234"
        let numero2 = 123
        let numero3 = 1.2345
        let concatenacion1 = numero + string;
        let concatenacion2 = numero + stringNumero;
        let concatenacion3 = numero + numero2;

        console.log(concatenacion1)
        console.log(concatenacion2)
        console.log(concatenacion3)

        console.log(typeof numero, "------------>", numero)
        console.log(typeof string, "------------>", string)
        console.log(typeof concatenacion1, "------------>", concatenacion1)
        console.log(typeof concatenacion2, "------------>", concatenacion2)
        console.log(typeof concatenacion3, "------------>", concatenacion3)
        console.log("------------metodos del objeto Number----------")

        console.log("método toFixed()", "------------>", numero3.toFixed(1))//modifica la cantidad de decimales
        console.log("método parseInt()", "------------>", parseInt(numero3))//devuelve parte entera
        console.log(`método Number() sobre variable stringNumero de valor: ${stringNumero} y tipo de dato: ${typeof stringNumero}   ------------------>    valor:${Number(stringNumero)} y tipo de dato: ${typeof Number(stringNumero)}`)


        console.log("----------------------------------------------------------------")
        console.log("***** ejemplo BOOLEANS*****")


        console.log(`valores falsy: 7    `)
        console.log(`1-----> 0 -----> ${Boolean(0)}`)
        console.log(`6-----> false----> ${Boolean(false)}`)
        console.log(`5-----> "" o '' (string vacío)------> ${Boolean("")}`)
        console.log(`4-----> undefined ---->${Boolean(undefined)}`)
        console.log(`2-----> null --->${Boolean(null)}`)
        console.log(`3-----> NaN ----->${Boolean(NaN)}`)
        console.log(`7-----> nodo no existente. Window.document.all---> ${Boolean(document.all)}`)


        console.log("***** ejemplo FUNCIONES*****")

        function funcionDevuelveValor() {
            console.log("uno")
            console.log("dos")
            console.log("tres")
            console.log("cuatro")
            console.log("cinco")
            return "terminó la función antes del seis"
        }

        const valorFuncion = funcionDevuelveValor()
        console.log(valorFuncion)//devuelve el valor de la funcion(return) por consola.

        console.log("---funcion con parametros---")
        function saludo(nombre = "desconocido", edad = 0) {
            console.log(`hola me llamo ${nombre} y tengo ${edad} años de edad`)
        }
        saludo()
        saludo("iñigo", 33)
        saludo("iñigo", "33")

        console.log("*****funciones declaradas vs funciones expresadas*****")
        console.log("---funciones declaradas---")
        duncionDeclarada()//javascript hace hoisting(elevacion de la funcion); JS ordena primero variables y luefo funciones.Por eso podemos invocar antes de declarar. 

        function duncionDeclarada() {
            console.log("Esto es una funcion declarada, puede invocarse en cualquier parte de nuestro código, incluso antes de que la función sea declarada")
        }

        duncionDeclarada()

        console.log("---funciones expresadas---")
        //utilizar las funciones como expresiones, es decir, crear una funcion y sasignarsela dinámicamente a una variable.

        //funcion anónima:

        // funcionExpresada()//da error ReferenceError.--

        const funcionExpresada = function () {
            console.log("esto es una funcion expresada, es decir que, una funcion que se le ha asignado como valor a una variable, si invocamos esta funcion antes de su declaracion JS nos dirá...")
        }
        funcionExpresada();//se muestra por consola.

        console.log("***** ejemplo ARRAYS*****")


        const colores = ["Rojo", "Verde", "Azul"];
        console.log(colores)
        colores.push("Naranja")
        console.log(colores)
        colores.forEach(function (element, index) {
            console.log(`<li id="${index}">${element}</li>`)
        })


        console.log("***** ejemplo OBJECTS*****")


        const Inigo = {
            nombre: "Inigo",
            apellido: "Malluguiza",
            edad: 33,
            pasatiempos: ["Esquí", "Rugby", "repostería"],
            soltero: false,
            contacto: {
                email: "inigomail@gmail.com",
                twitter: "@IngoTwitter",
                movil: "123456789"
            },
            saludar: function () {
                console.log("hola")
            },
            decirMiNombre: function () {
                console.log(`Hola me llamo ${this.nombre} ${this.apellido} y tengo ${this.edad} años. Me puedes segui como ${this.contacto.twitter} en twitter`)
            }

        }
        console.log(Inigo);
        console.log(Inigo.apellido);
        console.log(Inigo.pasatiempos[0]);
        console.log(Inigo.contacto.movil);
        Inigo.saludar()
        Inigo.decirMiNombre()


        console.log("***** ejemplo CONDICIONALES*****")
        console.log("---Métodos de Object---")

        console.log(Object.keys(Inigo))
        console.log(Object.values(Inigo))
        console.log(`con el método hasOwnProperty() podemos saber si la key "nombre" está contenida en el objeto Inigo: ${Inigo.hasOwnProperty("apellido")}`)
        console.log(Object.entries(Inigo) + "------------------------------")



        console.log("***** ejemplo OPERADORES aritméticos*****")
        // se corresponden a suma,resta,multiplicación,division y módulo
        let division = 5 / 2
        let modulo = 5 % 2
        console.log(`la variable division devuelve el cociente(resultado de la division) ${division}`)
        console.log(`la variable division devuelve el residuo o resto ${modulo}`)

        console.log("***** ejemplo OPERADORES relacionales*****")

        //= es asignacion
        //== es comparacion de valor
        console.log(`la operacion 7==7 es ${7 == 7}`)
        console.log(`la operacion "7"==7 es ${"7" == 7}`)
        //=== es comparacion de valor y tipo de dato
        console.log(`la operacion 7===7 es ${7 === 7}`)
        console.log(`la operacion "7"===7 es ${"7" === 7}`)


        console.log("***** ejemplo LOOPS*****")

        // console.log("while:")
        //estructura imperativa de programacion estructurada.

        let contador = 0;
        // contador < 10 ===> bucle infinito, hace falta incremento(++).
        while (contador < 10) {
            contador++
            console.log("while", contador)
        }


        // console.log(" do while:")

        do {
            console.log(" do while", contador)
            contador++
        } while (contador < 10)


        console.log("for:")

        let ArrayNum = ["cero", "uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez"]

        for (let i = 0; i < ArrayNum.length; i++) {
            console.log(i, ArrayNum[i])
        }


        const PruevaObject = {
            nombre: "ini",
            apellido: "Malluki",
            edad: 45
        }
        //for in para iterar las propiedades de un objeto primitivo
        //si queremos imprimir el valor de la propiedad de un objeto , la notacion del punto nos dará undefined.
        for (const propiedad in PruevaObject) {
            console.log(`key:${propiedad}, value: ${PruevaObject[propiedad]}`)
        }
        //for of permite recorrer o iterar los elementos de cualquier objeto en JS que sea iterable(que se puedan partir en pequeños elementos: strings, arrays, numeros...).
        for (const elemento of ArrayNum) {
            console.log(elemento)
        }
        let cadena = "Hola Mundo"
        for (const elemento of cadena) {
            console.log(elemento)
        }

        console.log("*****Ejemplo estructura de manejo de ERRORES:estructura => try-catch-finaly***** ")

        try {
            console.log("En el try se agrega el códio a evaluar.")
            error
            console.log("Segundo mensaje en el try.")

        } catch (error) {
            console.log("Catch captura cualquier error surgido o lanzado en el try.")
        } finally {
            console.log("El bloque finaly, se ejecutará siempre al final de un bloque try-catch.")
        }



        try {
            let number = "23";

            if (isNaN(number)) {
                throw new Error("El carácter introducido no es un Número")
            }
            console.log(number * number)

        } catch (error) {
            console.log(`Se produjo el siguiete error:${error}`)
        }

        console.log("*****Ejemplo break & continue***** ")
        //estas dos palabras no se pueden utilizar con metodos de los arrays como forEach.Están pensadas para ser utilizadas en estructuras de control como for,while,do while,if, switch, case, etc.
        const array = ["cero", 1, "dos", 3, "cuatro", 5, "seis", 7, "ocho", 9, "diez"]

        for (let i = 0; i < array.length; i++) {
            if (i === 5) {
                break;
            }
            console.log(array[i])
        }
        console.log("-----------------------")

        for (let i = 0; i < array.length; i++) {
            if (i === 5) {
                continue;
            }//salta la itesación numero 5
            console.log(array[i])
        }


        console.log("*****Destructuring***** ")

        let arreglo = [1, 2, 3]

        //Sin destructuración
        let uno = arreglo[0],
            dos = arreglo[1],
            tres = arreglo[2];

        console.log(uno, dos, tres)

        //Con destructuración
        const [one, two, three] = arreglo

        console.log(one, two, three);


        let usuario = {
            nombre: "Jon",
            apellido: "Martinez",
            edad: 50
        }
        //destructuramos el objeto usuario de la siguiente manera:
        let { nombre, apellido, age } = usuario
        console.log(nombre, apellido, age)
        //IMP: al destructurar las propiedades de un objeto se debe respetar los nombres de las propiedades del mismo.

        console.log("*****Objetos Literales***** ");
        //nueva forma de escribir atributos y metodos (incluso de saignarlos).
        //Sin nuevas caracteristicas de objetos literales:
        let nombre1 = "Argos",
            edad = 10;
        const perro = {
            nombre1: nombre1,
            edad: edad,
            ladrar: function () {
                console.log("guauuuuu guauuu")
            }
        }

        console.log(perro)
        perro.ladrar()

        //-----nuevas características-----------:simplificar.A partir del estandar ES6(2015)
        const dog = {
            nombre1,
            edad,
            raza: "mastín",
            ladrar() {
                console.log("soy un perro guaui guau...")
            }
        }
        console.log(dog)
        dog.ladrar()

        console.log("***** Parámetros REST & Operador Spread***** ");
        //parámetro REST:
        //parámetros que recibe una función
        function sumar(a, b, ...c) {
            let result = a + b

            c.forEach(function (n) {
                result += n
            })
            return result
        }
        console.log(sumar(1, 2))
        console.log(sumar(1, 2, 3, 4, 34, 2, 3, 45, 123))

        //Spread Operator u operador de propagación:
        //se puede ejecutar en cualquier sentencia de nuestro código.Quita las llaves y accede a los valores.

        const arr1 = [1, 2, 3, 4, 5, 6, 7],
            arr2 = [8, 9, 10, 11, 12, 13, 14, 15];

        console.log(arr1, arr2);

        const arr3 = [...arr1, ...arr2]

        console.log(arr3);


        console.log("*****Arrow Functions***** ")
        //nueva manera de simplificar las funciones expresadas(funciones anónimas).

        const arrow = function () {
            console.log("Hola, soy un arco expresado tradicional")
        }

        const arrowSimple = nombre => console.log(`Hola, soy un arco expresado simplificado y me llamo: ${nombre}`)

        arrow()
        arrowSimple("Irma")

        // const sumar2 = function (a, b) {
        //     return a + b
        // }
        // console.log(sumar2(1, 1))
        //se puede simplificar como:nos ahorramos el return(está implícito)
        const sumar2 = (a, b) => a + b
        console.log(sumar2(10, 10))

        const letras = ["a", "b", "c", "d", "e", "f", "g", "h"];

        letras.forEach(function (elem, index) {
            console.log(`el elemento: ${elem}, está en la posición :${index}`)
        })
        console.log("-----------con arrow function------")

        letras.forEach((elem, index) => console.log(`${elem}, está en la posición :${index}`))

        //IMPORTANTE: LAS ARROW FUNCTIONS TIENEN LA CAPACIDAD DE CAPTURAR EL OBJETO "THIS" DEL CONTEXTO EN EL QUE SE ENCUENTREN.EJEMPLO:

        // function samurai() {
        //     console.log(this)
        // }
        //como la funcion existe dentro del contexto del navegador, this se refiere al objeto window.
        // samurai()

        const huno = {
            nombre: "Atila",
            tribu: "hunos",
            gritar: function () {
                console.log(`soy ${this.nombre} y con la function expresada tradicional me refiero al objeto:`, this)
            },
            status() {
                console.log(`El rey de los ${this.tribu} soy YO:${this.nombre}aaaa!!!`)
            },
        }

        huno.gritar()//this en este contexto se refiere al objeto huno.
        huno.status()


        const huno2 = {
            nombre: "Atila",
            gritar: () => {
                console.log(`soy ${huno2.nombre} y con la function expresada arrow me refiero al objeto:`, this)
            },
        }

        huno2.gritar()//this en este contexto se refiere al objeto window.

//HAY QUE TENER MUCHO CUIDADO CON UTILIZAR ARROW FUNCTIONS PARA DECLARAR MÉTODOS DENTRO DE OBJETOS LITERALES.UNA FUNCION NORMAL RESPETA EL CONTEXTO EN EL QUE SE ENCUENTRA.Utilizar function expresada tradicional(no arrow) para metodos de objetos literales.



    </script>
</body>

</html>